/* eslint-disable */
import type { CallContext, CallOptions } from "nice-grpc-common";
import { AppendRequest, AppendResponse } from "./append.pb.js";
import { ContinueListRequest } from "./continue-list.pb.js";
import { DeleteRequest, DeleteResponse } from "./delete.pb.js";
import { GetRequest, GetResponse } from "./get.pb.js";
import { BeginListRequest, ListResponse } from "./list.pb.js";
import { PutRequest, PutResponse } from "./put.pb.js";
import { ScanRootPathsRequest, ScanRootPathsResponse } from "./scan-root-paths.pb.js";
import { SyncListRequest, SyncListResponse } from "./sync-list.pb.js";
import { TransactionRequest, TransactionResponse } from "./transaction.pb.js";

/**
 * Data is the service for creating, reading, updating and deleting data in a
 * StatelyDB Store. Creating and modifying Stores is done by the Management
 * service (though in the common case each project has an
 * automatically-generated default store that should be used for all data in
 * that project).
 */
export type DataDefinition = typeof DataDefinition;
export const DataDefinition = {
  name: "Data",
  fullName: "stately.Data",
  methods: {
    /**
     * Put adds one or more Items to the Store, or replaces the Items if they
     * already exist at that path. This will fail if any of the PutItem requests'
     * write conditions fails, or if the caller does not have permission to create
     * Items. You may choose whether all puts in the request are applied
     * atomically (in a transaction) or not, though some store configurations may
     * always apply the whole batch in a transaction (such as in version-tracking
     * stores). The status of each Put operation is returned in the response. Data
     * can be provided as either JSON, or as a proto encoded by a previously
     * agreed upon schema, or by some combination of the two.
     */
    put: {
      name: "Put",
      requestType: PutRequest,
      requestStream: false,
      responseType: PutResponse,
      responseStream: false,
      options: { idempotencyLevel: "IDEMPOTENT" },
    },
    /**
     * Get retrieves one or more Items by their full key paths. This will return
     * any of the Items that exist. It will fail if the caller does not have
     * permission to read Items. Use Query if you want to retrieve multiple items
     * but don't already know the full key paths of the items you want to get.
     */
    get: {
      name: "Get",
      requestType: GetRequest,
      requestStream: false,
      responseType: GetResponse,
      responseStream: false,
      options: { idempotencyLevel: "NO_SIDE_EFFECTS" },
    },
    /**
     * Delete removes one or more Items from the Store by their full key paths.
     * This will fail if the caller does not have permission to delete Items. In
     * version-tracking stores, tombstones will be left for deleted items for some
     * predetermined time. You may choose whether all deletes in the request are
     * applied atomically (in a transaction) or not, though some store types may
     * always apply the whole batch in a transaction (such as in version-tracking
     * stores). The status of each Delete operation is returned in the response.
     */
    delete: {
      name: "Delete",
      requestType: DeleteRequest,
      requestStream: false,
      responseType: DeleteResponse,
      responseStream: false,
      options: { idempotencyLevel: "IDEMPOTENT" },
    },
    /**
     * Append adds one or more new Items to a parent path, automatically assigning
     * IDs via one of several selectable ID generation strategies (not all
     * strategies may be available to all store configurations or path types).
     * Because the ID is generated by the server, the new item is guaranteed not
     * to overwrite an existing Item. This differs from Put specifically because
     * of this ID assignment behavior, and it is recommended over Put for new
     * items where you do not want to assign IDs yourself. The assigned IDs will
     * be returned in the response. This operation will fail if the caller does
     * not have permission to create Items.
     */
    append: {
      name: "Append",
      requestType: AppendRequest,
      requestStream: false,
      responseType: AppendResponse,
      responseStream: false,
      options: {},
    },
    /**
     * BeginList loads Items that start with a specified key path, subject to
     * additional filtering. The prefix must minimally contain a Group Key (an
     * item type and an item ID). BeginList will return an empty result set if
     * there are no items matching that key prefix. A token is returned from this
     * API that you can then pass to ContinueList to expand the result set, or to
     * SyncList to get updates within the result set. This can fail if the caller
     * does not have permission to read Items.
     */
    beginList: {
      name: "BeginList",
      requestType: BeginListRequest,
      requestStream: false,
      responseType: ListResponse,
      responseStream: true,
      options: { idempotencyLevel: "NO_SIDE_EFFECTS" },
    },
    /**
     * ContinueList takes the token from a BeginList call and returns the next
     * "page" of results based on the original query parameters and pagination
     * options. It has few options because it is a continuation of a previous list
     * operation. It will return a new  token which can be used for another
     * ContinueList call, and so on. The  token is the same one used by SyncList -
     * each time you call either ContinueList or SyncList, you should pass the
     * latest version of the token, and then use the new token from the result in
     * subsequent calls. You may interleave ContinueList and SyncList calls
     * however you like, but it does not make sense to make both calls in
     * parallel. Calls to ContinueList are tied to the authorization of the
     * original BeginList call, so if the original BeginList call was allowed,
     * ContinueList with its token should also be allowed.
     */
    continueList: {
      name: "ContinueList",
      requestType: ContinueListRequest,
      requestStream: false,
      responseType: ListResponse,
      responseStream: true,
      options: { idempotencyLevel: "NO_SIDE_EFFECTS" },
    },
    /**
     * SyncList returns all changes to Items within the result set of a previous
     * List operation. For all Items within the result set that were modified, it
     * returns the full Item at in its current state. It also returns a list of
     * Item key paths that were deleted since the last SyncList, which you should
     * reconcile with your view of items returned from previous
     * BeginList/ContinueList calls. Using this API, you can start with an initial
     * set of items from BeginList, and then stay up to date on any changes via
     * repeated SyncList requests over time. The token is the same one used by
     * ContinueList - each time you call either ContinueList or SyncList, you
     * should pass the latest version of the token, and then use the new token
     * from the result in subsequent calls. Note that if the result set has
     * already been expanded to the end (in the direction of the original
     * BeginList request), SyncList will return newly created Items. You may
     * interleave ContinueList and SyncList calls however you like, but it does
     * not make sense to make both calls in parallel. Calls to SyncList are tied
     * to the authorization of the original BeginList call, so if the original
     * BeginList call was allowed, SyncList with its token should also be allowed.
     */
    syncList: {
      name: "SyncList",
      requestType: SyncListRequest,
      requestStream: false,
      responseType: SyncListResponse,
      responseStream: true,
      options: { idempotencyLevel: "NO_SIDE_EFFECTS" },
    },
    /**
     * Transaction performs a transaction, within which you can issue writes and
     * reads in any order, followed by a commit message. Reads are guaranteed to
     * reflect the state as of when the transaction started, and writes are
     * committed atomically. This method may fail if another transaction commits
     * before this one finishes - in that case, you should retry your transaction.
     */
    transaction: {
      name: "Transaction",
      requestType: TransactionRequest,
      requestStream: true,
      responseType: TransactionResponse,
      responseStream: true,
      options: {},
    },
    /**
     * ScanRootPaths lists root paths (Groups) in the Store, subject to optional
     * filters. This may be a very expensive operation, as it must consult
     * multiple partitions that may be distributed around the world. It is
     * provided mostly for use in the web console's data browser and may not be
     * exposed to customers. This operation will fail if the caller does not have
     * permission to read Items.
     */
    scanRootPaths: {
      name: "ScanRootPaths",
      requestType: ScanRootPathsRequest,
      requestStream: false,
      responseType: ScanRootPathsResponse,
      responseStream: false,
      options: { idempotencyLevel: "NO_SIDE_EFFECTS" },
    },
  },
} as const;

export interface DataServiceImplementation<CallContextExt = {}> {
  /**
   * Put adds one or more Items to the Store, or replaces the Items if they
   * already exist at that path. This will fail if any of the PutItem requests'
   * write conditions fails, or if the caller does not have permission to create
   * Items. You may choose whether all puts in the request are applied
   * atomically (in a transaction) or not, though some store configurations may
   * always apply the whole batch in a transaction (such as in version-tracking
   * stores). The status of each Put operation is returned in the response. Data
   * can be provided as either JSON, or as a proto encoded by a previously
   * agreed upon schema, or by some combination of the two.
   */
  put(request: PutRequest, context: CallContext & CallContextExt): Promise<PutResponse>;
  /**
   * Get retrieves one or more Items by their full key paths. This will return
   * any of the Items that exist. It will fail if the caller does not have
   * permission to read Items. Use Query if you want to retrieve multiple items
   * but don't already know the full key paths of the items you want to get.
   */
  get(request: GetRequest, context: CallContext & CallContextExt): Promise<GetResponse>;
  /**
   * Delete removes one or more Items from the Store by their full key paths.
   * This will fail if the caller does not have permission to delete Items. In
   * version-tracking stores, tombstones will be left for deleted items for some
   * predetermined time. You may choose whether all deletes in the request are
   * applied atomically (in a transaction) or not, though some store types may
   * always apply the whole batch in a transaction (such as in version-tracking
   * stores). The status of each Delete operation is returned in the response.
   */
  delete(request: DeleteRequest, context: CallContext & CallContextExt): Promise<DeleteResponse>;
  /**
   * Append adds one or more new Items to a parent path, automatically assigning
   * IDs via one of several selectable ID generation strategies (not all
   * strategies may be available to all store configurations or path types).
   * Because the ID is generated by the server, the new item is guaranteed not
   * to overwrite an existing Item. This differs from Put specifically because
   * of this ID assignment behavior, and it is recommended over Put for new
   * items where you do not want to assign IDs yourself. The assigned IDs will
   * be returned in the response. This operation will fail if the caller does
   * not have permission to create Items.
   */
  append(request: AppendRequest, context: CallContext & CallContextExt): Promise<AppendResponse>;
  /**
   * BeginList loads Items that start with a specified key path, subject to
   * additional filtering. The prefix must minimally contain a Group Key (an
   * item type and an item ID). BeginList will return an empty result set if
   * there are no items matching that key prefix. A token is returned from this
   * API that you can then pass to ContinueList to expand the result set, or to
   * SyncList to get updates within the result set. This can fail if the caller
   * does not have permission to read Items.
   */
  beginList(
    request: BeginListRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<ListResponse>;
  /**
   * ContinueList takes the token from a BeginList call and returns the next
   * "page" of results based on the original query parameters and pagination
   * options. It has few options because it is a continuation of a previous list
   * operation. It will return a new  token which can be used for another
   * ContinueList call, and so on. The  token is the same one used by SyncList -
   * each time you call either ContinueList or SyncList, you should pass the
   * latest version of the token, and then use the new token from the result in
   * subsequent calls. You may interleave ContinueList and SyncList calls
   * however you like, but it does not make sense to make both calls in
   * parallel. Calls to ContinueList are tied to the authorization of the
   * original BeginList call, so if the original BeginList call was allowed,
   * ContinueList with its token should also be allowed.
   */
  continueList(
    request: ContinueListRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<ListResponse>;
  /**
   * SyncList returns all changes to Items within the result set of a previous
   * List operation. For all Items within the result set that were modified, it
   * returns the full Item at in its current state. It also returns a list of
   * Item key paths that were deleted since the last SyncList, which you should
   * reconcile with your view of items returned from previous
   * BeginList/ContinueList calls. Using this API, you can start with an initial
   * set of items from BeginList, and then stay up to date on any changes via
   * repeated SyncList requests over time. The token is the same one used by
   * ContinueList - each time you call either ContinueList or SyncList, you
   * should pass the latest version of the token, and then use the new token
   * from the result in subsequent calls. Note that if the result set has
   * already been expanded to the end (in the direction of the original
   * BeginList request), SyncList will return newly created Items. You may
   * interleave ContinueList and SyncList calls however you like, but it does
   * not make sense to make both calls in parallel. Calls to SyncList are tied
   * to the authorization of the original BeginList call, so if the original
   * BeginList call was allowed, SyncList with its token should also be allowed.
   */
  syncList(
    request: SyncListRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<SyncListResponse>;
  /**
   * Transaction performs a transaction, within which you can issue writes and
   * reads in any order, followed by a commit message. Reads are guaranteed to
   * reflect the state as of when the transaction started, and writes are
   * committed atomically. This method may fail if another transaction commits
   * before this one finishes - in that case, you should retry your transaction.
   */
  transaction(
    request: AsyncIterable<TransactionRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<TransactionResponse>;
  /**
   * ScanRootPaths lists root paths (Groups) in the Store, subject to optional
   * filters. This may be a very expensive operation, as it must consult
   * multiple partitions that may be distributed around the world. It is
   * provided mostly for use in the web console's data browser and may not be
   * exposed to customers. This operation will fail if the caller does not have
   * permission to read Items.
   */
  scanRootPaths(
    request: ScanRootPathsRequest,
    context: CallContext & CallContextExt,
  ): Promise<ScanRootPathsResponse>;
}

export interface DataClient<CallOptionsExt = {}> {
  /**
   * Put adds one or more Items to the Store, or replaces the Items if they
   * already exist at that path. This will fail if any of the PutItem requests'
   * write conditions fails, or if the caller does not have permission to create
   * Items. You may choose whether all puts in the request are applied
   * atomically (in a transaction) or not, though some store configurations may
   * always apply the whole batch in a transaction (such as in version-tracking
   * stores). The status of each Put operation is returned in the response. Data
   * can be provided as either JSON, or as a proto encoded by a previously
   * agreed upon schema, or by some combination of the two.
   */
  put(request: PutRequest, options?: CallOptions & CallOptionsExt): Promise<PutResponse>;
  /**
   * Get retrieves one or more Items by their full key paths. This will return
   * any of the Items that exist. It will fail if the caller does not have
   * permission to read Items. Use Query if you want to retrieve multiple items
   * but don't already know the full key paths of the items you want to get.
   */
  get(request: GetRequest, options?: CallOptions & CallOptionsExt): Promise<GetResponse>;
  /**
   * Delete removes one or more Items from the Store by their full key paths.
   * This will fail if the caller does not have permission to delete Items. In
   * version-tracking stores, tombstones will be left for deleted items for some
   * predetermined time. You may choose whether all deletes in the request are
   * applied atomically (in a transaction) or not, though some store types may
   * always apply the whole batch in a transaction (such as in version-tracking
   * stores). The status of each Delete operation is returned in the response.
   */
  delete(request: DeleteRequest, options?: CallOptions & CallOptionsExt): Promise<DeleteResponse>;
  /**
   * Append adds one or more new Items to a parent path, automatically assigning
   * IDs via one of several selectable ID generation strategies (not all
   * strategies may be available to all store configurations or path types).
   * Because the ID is generated by the server, the new item is guaranteed not
   * to overwrite an existing Item. This differs from Put specifically because
   * of this ID assignment behavior, and it is recommended over Put for new
   * items where you do not want to assign IDs yourself. The assigned IDs will
   * be returned in the response. This operation will fail if the caller does
   * not have permission to create Items.
   */
  append(request: AppendRequest, options?: CallOptions & CallOptionsExt): Promise<AppendResponse>;
  /**
   * BeginList loads Items that start with a specified key path, subject to
   * additional filtering. The prefix must minimally contain a Group Key (an
   * item type and an item ID). BeginList will return an empty result set if
   * there are no items matching that key prefix. A token is returned from this
   * API that you can then pass to ContinueList to expand the result set, or to
   * SyncList to get updates within the result set. This can fail if the caller
   * does not have permission to read Items.
   */
  beginList(
    request: BeginListRequest,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<ListResponse>;
  /**
   * ContinueList takes the token from a BeginList call and returns the next
   * "page" of results based on the original query parameters and pagination
   * options. It has few options because it is a continuation of a previous list
   * operation. It will return a new  token which can be used for another
   * ContinueList call, and so on. The  token is the same one used by SyncList -
   * each time you call either ContinueList or SyncList, you should pass the
   * latest version of the token, and then use the new token from the result in
   * subsequent calls. You may interleave ContinueList and SyncList calls
   * however you like, but it does not make sense to make both calls in
   * parallel. Calls to ContinueList are tied to the authorization of the
   * original BeginList call, so if the original BeginList call was allowed,
   * ContinueList with its token should also be allowed.
   */
  continueList(
    request: ContinueListRequest,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<ListResponse>;
  /**
   * SyncList returns all changes to Items within the result set of a previous
   * List operation. For all Items within the result set that were modified, it
   * returns the full Item at in its current state. It also returns a list of
   * Item key paths that were deleted since the last SyncList, which you should
   * reconcile with your view of items returned from previous
   * BeginList/ContinueList calls. Using this API, you can start with an initial
   * set of items from BeginList, and then stay up to date on any changes via
   * repeated SyncList requests over time. The token is the same one used by
   * ContinueList - each time you call either ContinueList or SyncList, you
   * should pass the latest version of the token, and then use the new token
   * from the result in subsequent calls. Note that if the result set has
   * already been expanded to the end (in the direction of the original
   * BeginList request), SyncList will return newly created Items. You may
   * interleave ContinueList and SyncList calls however you like, but it does
   * not make sense to make both calls in parallel. Calls to SyncList are tied
   * to the authorization of the original BeginList call, so if the original
   * BeginList call was allowed, SyncList with its token should also be allowed.
   */
  syncList(
    request: SyncListRequest,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SyncListResponse>;
  /**
   * Transaction performs a transaction, within which you can issue writes and
   * reads in any order, followed by a commit message. Reads are guaranteed to
   * reflect the state as of when the transaction started, and writes are
   * committed atomically. This method may fail if another transaction commits
   * before this one finishes - in that case, you should retry your transaction.
   */
  transaction(
    request: AsyncIterable<TransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<TransactionResponse>;
  /**
   * ScanRootPaths lists root paths (Groups) in the Store, subject to optional
   * filters. This may be a very expensive operation, as it must consult
   * multiple partitions that may be distributed around the world. It is
   * provided mostly for use in the web console's data browser and may not be
   * exposed to customers. This operation will fail if the caller does not have
   * permission to read Items.
   */
  scanRootPaths(
    request: ScanRootPathsRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ScanRootPathsResponse>;
}

export type ServerStreamingMethodResult<Response> = {
  [Symbol.asyncIterator](): AsyncIterator<Response, void>;
};
