/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { StoreInfo } from "../dbmanagement/store-info.pb.js";
import { Organization } from "./organization.pb.js";
import { Project } from "./project.pb.js";

/**
 * Nothing here - the auth token contains the user ID. Later this could maybe
 * include some options on what information to retrieve.
 */
export interface WhoamiRequest {}

/**
 * Lots of user info (picture, name, etc) are managed by Auth0 and are
 * embedded in the auth token, so we don't need to return that. Potentially,
 * everything could be in the auth token but who knows, you'd have to regen
 * the token when the user edited anything.
 */
export interface WhoamiResponse {
  /**
   * oauth_subject is the user's ID in Auth0. We already have this from the auth token
   * but it can't hurt to return it so we can validate that what we have locally
   * is still what we thought.
   */
  oauthSubject: string;
  /**
   * user_id is the user's ID in Stately. This is generated by us during enrollment
   * and can may also be referred to as member ID within Stately.
   */
  userId: bigint;
  /**
   * email is the user's email address. This can be missing if this is a machine
   * user.
   * TODO: In the future we'll want to replace this with a list of emails,
   * verification status, etc.
   */
  email: string;
  /** enrollment_time is the UTC epoch of when the User was created. */
  enrollmentTime: bigint;
  /** display_name is the user's display name. */
  displayName: string;
  /** organizations is a tree of the organizations, their projects and their stores. */
  organizations: OrganizationNode[];
}

export interface OrganizationNode {
  /** organization contains details about an organization. */
  organization: Organization | undefined;
  /** projects is a list of projects that belong to this organization. */
  projects: ProjectNode[];
}

export interface ProjectNode {
  /** project contains details about a project. */
  project: Project | undefined;
  /** stores is a list of stores that belong to this project. */
  stores: StoreNode[];
}

export interface StoreNode {
  /** store contains details about a store. */
  store: StoreInfo | undefined;
}

function createBaseWhoamiRequest(): WhoamiRequest {
  return {};
}

export const WhoamiRequest = {
  encode(_: WhoamiRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhoamiRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhoamiRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseWhoamiResponse(): WhoamiResponse {
  return {
    oauthSubject: "",
    userId: BigInt("0"),
    email: "",
    enrollmentTime: BigInt("0"),
    displayName: "",
    organizations: [],
  };
}

export const WhoamiResponse = {
  encode(message: WhoamiResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oauthSubject !== "") {
      writer.uint32(10).string(message.oauthSubject);
    }
    if (message.userId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.userId) !== message.userId) {
        throw new globalThis.Error(
          "value provided for field message.userId of type uint64 too large",
        );
      }
      writer.uint32(16).uint64(message.userId.toString());
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.enrollmentTime !== BigInt("0")) {
      if (BigInt.asUintN(64, message.enrollmentTime) !== message.enrollmentTime) {
        throw new globalThis.Error(
          "value provided for field message.enrollmentTime of type uint64 too large",
        );
      }
      writer.uint32(32).uint64(message.enrollmentTime.toString());
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    for (const v of message.organizations) {
      OrganizationNode.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhoamiResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhoamiResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oauthSubject = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enrollmentTime = longToBigint(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.organizations.push(OrganizationNode.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrganizationNode(): OrganizationNode {
  return { organization: undefined, projects: [] };
}

export const OrganizationNode = {
  encode(message: OrganizationNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== undefined) {
      Organization.encode(message.organization, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.projects) {
      ProjectNode.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrganizationNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organization = Organization.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projects.push(ProjectNode.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseProjectNode(): ProjectNode {
  return { project: undefined, stores: [] };
}

export const ProjectNode = {
  encode(message: ProjectNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.stores) {
      StoreNode.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProjectNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProjectNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = Project.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stores.push(StoreNode.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseStoreNode(): StoreNode {
  return { store: undefined };
}

export const StoreNode = {
  encode(message: StoreNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.store !== undefined) {
      StoreInfo.encode(message.store, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StoreNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.store = StoreInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
