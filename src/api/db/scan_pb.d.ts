// @generated by protoc-gen-es v2.2.3 with parameter "target=js+dts,import_extension=.js"
// @generated from file db/scan.proto (package stately.db, syntax proto3)
/* eslint-disable */

import type { Message } from "@bufbuild/protobuf";
import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";

/**
 * Describes the file db/scan.proto.
 */
export declare const file_db_scan: GenFile;

/**
 * @generated from message stately.db.FilterCondition
 */
export declare type FilterCondition = Message<"stately.db.FilterCondition"> & {
  /**
   * @generated from oneof stately.db.FilterCondition.value
   */
  value:
    | {
        /**
         * item_type is the type of item to filter by.
         *
         * @generated from field: string item_type = 1;
         */
        value: string;
        case: "itemType";
      }
    | { case: undefined; value?: undefined };
};

/**
 * Describes the message stately.db.FilterCondition.
 * Use `create(FilterConditionSchema)` to create a new message.
 */
export declare const FilterConditionSchema: GenMessage<FilterCondition>;

/**
 * @generated from message stately.db.BeginScanRequest
 */
export declare type BeginScanRequest = Message<"stately.db.BeginScanRequest"> & {
  /**
   * store_id is a globally unique Store ID, which can be looked up from the
   * console or CLI.
   *
   * @generated from field: uint64 store_id = 1;
   */
  storeId: bigint;

  /**
   * filter_condition is a set of conditions to filter the scan result by.
   * If no conditions are provided, all items in the store will be returned.
   * Filter conditions are combined with OR.
   *
   * @generated from field: repeated stately.db.FilterCondition filter_condition = 2;
   */
  filterCondition: FilterCondition[];

  /**
   * limit is the maximum number of items to return. If this is not specified or
   * set to 0, it will return one server side page of items, which may contain zero of your selected
   * item types and hence be an empty response.
   * Be sure to check token.can_continue to see if you have more items left to fetch.
   *
   * @generated from field: uint32 limit = 3;
   */
  limit: number;

  /**
   * segmentation_params is used to enable parallelization of the list operation.
   * This is useful for bulk processing of large stores.
   * If this field is set then the list operation will be split into segment_params.total_segments
   * and this request will process the segment defined in segmentation_params.segment_index.
   * See SegmentationParams for more details.
   * Please be warned that parallelization will result on increase throughput to your store
   * which may result in throttling.
   *
   * @generated from field: stately.db.SegmentationParams segmentation_params = 4;
   */
  segmentationParams?: SegmentationParams;

  /**
   * schema_version_id refers to the item version to return.
   * If the store's schema does not have this version, the operation
   * will error with SchemaVersionNotFound error. You should not have to
   * set this manually as your generated SDK should know its schema version
   * and wire this in for you.
   *
   * @generated from field: uint32 schema_version_id = 5;
   */
  schemaVersionId: number;
};

/**
 * Describes the message stately.db.BeginScanRequest.
 * Use `create(BeginScanRequestSchema)` to create a new message.
 */
export declare const BeginScanRequestSchema: GenMessage<BeginScanRequest>;

/**
 * @generated from message stately.db.SegmentationParams
 */
export declare type SegmentationParams = Message<"stately.db.SegmentationParams"> & {
  /**
   * total_segments is used to determine the number of segments the store will be split into.
   * The segment_index field will then be used to determine which segment to process.
   * For example, if total_segments is set to 5 then the store will be split into 5 segments
   * and by setting segment_index to 0, 1, 2, 3, or 4 the request will process the corresponding
   * segment.
   *
   * @generated from field: uint32 total_segments = 5;
   */
  totalSegments: number;

  /**
   * segment_index is used to determine which segment of the store to process
   * with this request.
   * Segments are zero-indexed so the value of segment_index must be less than total_segments.
   *
   * @generated from field: uint32 segment_index = 6;
   */
  segmentIndex: number;
};

/**
 * Describes the message stately.db.SegmentationParams.
 * Use `create(SegmentationParamsSchema)` to create a new message.
 */
export declare const SegmentationParamsSchema: GenMessage<SegmentationParams>;
